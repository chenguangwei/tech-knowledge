### Java位运算

#### 表示方法　

在Java语言中，二进制数使用补码表示，最高位为符号位，正数的符号位为0，负数为1。补码的表示需要满足如下要求。 　
(1)正数的最高位为0，其余各位代表数值本身(二进制数)。 　
(2)对于负数，通过对该数绝对值的补码按位取反，再对整个数加1。

#### 位运算符

位运算表达式由操作数和位运算符组成，实现对整数类型的二进制数进行位运算。位运算符可以分为逻辑运算符(包括~、＆、|和^)及移位运算符(包括>>、<<和>>>)。

```
1)左移位运算符（<<）能将运算符左边的运算对象向左移动运算符右侧指定的位数（在低位补0）。
2)“有符号”右移位运算符（>>）则将运算符左边的运算对象向右移动运算符右侧指定的位数。 “有符号”右移位运算符使用了“符号扩展”：若值为正，则在高位插入0；若值为负，则在高位插入1。
3)Java也添加了一种“无符号”右移位运算符（>>>），它使用了“零扩展”：无论正负，都在高位插入0。这一运算符是C或C++没有的。
4)若对char，byte或者short进行移位处理，那么在移位进行之前，它们会自动转换成一个int。 只有右侧的5个低位才会用到。这样可防止我们在一个int数里移动不切实际的位数。 若对一个long值进行处理，最后得到的结果也是long。此时只会用到右侧的6个低位，防止移动超过long值里现成的位数。 但在进行“无符号”右移位时，也可能遇到一个问题。若对byte或short值进行右移位运算，得到的可能不是正确的结果（Java 1.0和Java 1.1特别突出）。 它们会自动转换成int类型，并进行右移位。但“零扩展”不会发生，所以在那些情况下会得到-1的结果。
```



在进行位运算时，需要注意以下几点:

```
(1)>>>和>>的区别是：在执行运算时，>>>运算符的操作数高位补0，而>>运算符的操作数高位移入原来高位的值。
(2)右移一位相当于除以2，左移一位(在不溢出的情况下)相当于乘以2；移位运算速度高于乘除运算。
(3)若进行位逻辑运算的两个操作数的数据长度不相同，则返回值应该是数据长度较长的数据类型。
(4)按位异或可以不使用临时变量完成两个值的交换，也可以使某个整型数的特定位的值翻转。
(5)按位与运算可以用来屏蔽特定的位，也可以用来取某个数型数中某些特定的位。
(6)按位或运算可以用来对某个整型数的特定位的值置l。
```



#### 位运算符的优先级

~的优先级最高，其次是<<、>>和>>>，再次是＆，然后是^，优先级最低的是|。

### 位运算的应用

1. 判断int型变量a是奇数还是偶数

   ```
   a&1 == 0 偶数
   a&1 == 1 奇数
   ```

2. 求平均值，比如有两个int类型变量x、y,首先要求x+y的和，再除以2，但是有可能x+y的结果会超过int的最大表示范围，所以位运算就派上用场啦。

   ```
         (x&y)+((x^y)>>1);
   
   知识点：>>n 相当于除于2^n ，<<n 相当于乘于2^n 。
   x,y对应位均为1，相加后再除以2还是原来的数，如两个00001000相加后除以2仍得00001000,那么我们把x与y分别分成两个部分来看,两者相同的位分别拿出来 则 :
   x = (111111111111000)2 =  (111111111111000)2 +  (000000000000000)2
   y =  (111111111111010)2 =  (111111111111000)2 +  (000000000000010)2
   相同部分我们叫做x1,y1,不同部分我们叫做x2,y2.那么现在(x+y)/2 =(x1+y1)/2 +(x2 + y2)/2 ,因为x1 == y1 ,所以(x1+y1)/2 ==x1 ==y1,相同部分我们用与运算求出来 x1 = x&y ,不同部分的和我们用^求出来,然后除于2就是我们想要的结果了。
   ```

3. 对于一个大于0的整数，判断它是不是2的几次方

   ```
   ((x&(x-1))==0)&&(x!=0)；
   /*如果是2的幂，n一定是100... n-1就是1111....
      所以做与运算结果为0*/
   ```

4. 比如有两个int类型变量x、y,要求两者数字交换，位运算的实现方法：性能绝对高效

   ```
   x ^= y;
   y ^= x;
   x ^= y;
   ```

5. 求绝对值

   ```
    int abs( int x )
   {
     int y ;
     y = x >> 31 ;
    return (x^y)-y ;        //or: (x+y)^y
   }
   ```

6. 取模运算，采用位运算实现

   ```
   a % (2^n) 等价于 a & (2^n - 1) ;或者 m % n 等价于 m & (n-1)
   ```

7. 乘法运算 采用位运算实现

   ```
   a * (2^n) 等价于 a << n
   ```

8. 除法运算转化成位运算

   ```
   a / (2^n) 等价于 a>> n
   ```

9. 求相反数

   ```
   (~x+1)
   ```

10. a % 2 等价于

    ```
    a & 1
    ```

11. 取int型变量a的第k位 (k=0,1,2……sizeof(int))

    ```
    a>>k&1   (先右移再与1)
    ```

12. 将int型变量a的第k位清0

    ```
    a&~(1<<k)    (10000 取反后为00001 )
    ```

13. 将int型变量a的第k位置1

    ```
    a|(1<<k)
    ```

14. int型变量循环左移k次

    ```
    a<<k|a>>16-k   (设sizeof(int)=16)
    ```

15. int型变量a循环右移k次

    ```
    a>>k|a<<16-k   (设sizeof(int)=16)
    ```

16. 对于一个数 x >= 0，判断是不是2的幂。

    ```
    boolean isPower2(int x) {
        return ((x&(x-1))==0) && (x!=0);
    }
    ```

17. 不用temp交换两个整数

    ```
    void swap(int x , int y) {
        x ^= y;
        y ^= x;
        x ^= y;
    }
    ```

18. 条件判断赋值简写

    ```
      if (x == a)
          x= b;
    　　 else
          x= a;
    
    等价于 x= a ^ b ^ x;
    ```

19. x的相反数

    ```
    (~x+1)
    ```

20. m乘以2的n次方

    ```
    m << n
    ```

21. m除以以2的n次方

    ```
    m >> n
    ```

22. 求整数k从x位（高）到y位（低）间共有多少个1

    ```
    public static int findChessNum(int x, int y, int k) {
      int result = 0;
      for (int i = y; i <= x; i++) {
        result += ((k >> (i - 1)) & 1);
      }
      return result;
      }
    ```

23. 取绝对值

    ```
      int abs(int n){
          return (n ^ (n >> 31)) - (n >> 31);
      }
    /* n>>31 取得n的符号，若n为正数，n>>31等于0，若n为负数，n>>31等于-1
    若n为正数 n^0=0,数不变，若n为负数有n^-1 需要计算n和-1的补码，然后进行异或运算， 结果n变号并且为n的绝对值减1，再减去-1就是绝对值 */
    ```

24. 只出现一次的数字
    给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
    说明:你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
    示例 1:

    ```
    输入: [2,2,1]输出: 1
    ```

示例 2:

```
输入: [4,1,2,1,2]输出: 4
```



这个题首先想到的就是异或的特性。相同的数字异或的结果为 0，那么出现奇数次的一定就是最后我们想要的结果。

```
public int singleNum(int[] nums){
    int res = num[0];
    for(int i=1;i<nums.length;i++){
        res ^= nums[i];
    }
    return res;
}
```



1. 寻找重复数

   给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

   示例 1:

   ```
   输入: [1,3,4,2,2]输出: 2
   ```

示例 2:

```
输入: [3,1,3,4,2]输出: 3
```



说明：

- 不能更改原数组（假设数组是只读的）。
- 只能使用额外的 O(1) 的空间。
- 时间复杂度小于 O(n2) 。
- 数组中只有一个重复的数字，但它可能不止重复出现一次。

我们注意看下题目，题目明确说明了数组 nums 包含 1 和 n ，并且只有一个重复的整数，如果不考虑说明中的第四点的话这段代码是正确的。解释一下原理。a 从 1 一直异或到 n，其中有一个重复的数字 x ，那么就是 1 ^ 2 ^ 3 ··· ^ x ^ x ^ ··· ^ n。异或操作因为是半加运算，因此是满足交换律的，我们把 x 拿到最后面， 即 1 ^ 2 ^ 3 ··· ^ n ^ x ^ x，而 x ^ x 一定是 0 ，因此 1 ~ n 每个数异或了 2 次，而 x 异或了 3 次，所以最后 res 的值就是我们要找的 x 的值。

```
//先不考虑“数组中只有一个重复的数字，但它可能不止重复出现一次”这个条件
public int findDumplicate(int[] nums){
    int res = 0;
    for(int i=0;i<nums.length;i++){
        res ^= nums[i];
        res ^= i;
    }
    return res;
}
```



但是有了第四点，这个方法就不太好用了，下面是一个正确的解法，由于跟异或没有太多的关系，因此就不过多解释。

```
public int findDumplicate(int[] nums){
    if(nums.length>1){
        int slow = nums[0];
        int fast = nums[nums[0]];
        while(slow != fast){
            slow = nums[slow];
            fast = nums[nums[fast]];
        }

        fast = 0;
        while(fast != slow){
            fast = nums[fast];
            slow = nums[slow];
        }
        return slow;
    }

    return -1;
}
```



1. 找不同
   给定两个字符串 s 和 t，它们只包含小写字母。字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。请找出在 t 中被添加的字母。

示例：

```
输入：s = "abcd"  t = "abcde"  输出：e
```



解释：’e’ 是那个被添加的字母。

这个题目如果想不到用异或运算的话，写起来可能真的会有点麻烦。我们想到异或运算的特点，a ^ a = 0，如果插入了一个字母的话，那么这个两个字符串中，出现的次数肯定是奇数次，而其他的都是偶数次，所以直接把所有的字符都异或一遍，答案自然就出来了！

```
public char findTheDifference(String s,String t) {
    char res = t.charAt(0);
    for (int i = 0; i < s.length(); i++) {
        res ^= s.charAt(i);
    }
    for (int i = 1; i < t.length(); i++) {
        res ^= t.charAt(i);
    }
    return res;
}


public char findTheDifference2(String s, String t) {
    char c = 0;
    for (int i = 0; i < s.length(); i++) {
        c ^= s.charAt(i);
    }
    for (int i = 0; i < t.length(); i++) {
        c ^= t.charAt(i);
    }
    return c;
}
```



注意上面两种写法，方法一第二次循环从1开始，方法二第二次循环从0开始，why?

之前还有一个面试题目，就是有 N + 1 块相同容量的硬盘，其中 N 块用来存储数据，如果利用多余的 1 块硬盘来存储 N 块硬盘的数据备份，假设硬盘最多同时只会损坏 1 块。我想通过上面几个题，大家应该很快想到存储办法了吧，答案就是多余的 1 块硬盘存储 N 块硬盘异或的结果，那么当其中 1 块硬盘损坏的时候，只需要把其他好的硬盘数据再异或一遍，即可得到损坏的硬盘的数据了。

通过上面的例子，我们发现在查找“奇数个”的数据的时候，异或运算用起来还是非常方便的。异或运算还有很多其他的应用，比如简单的加密数据，加密：result = a ^ password，解密：a = result ^ password。
异或运算很简单，难点在于遇到问题能不能想到利用异或运算来解决问题，这就需要我们在编程过程中一点点积累经验。

### 总结

| 功能                  | 示例                   | 位运算              |
| --------------------- | ---------------------- | ------------------- |
| 去掉最后一位          | (101101->10110)        | x >> 1              |
| 在最后加一个0         | (101101->1011010)      | x < < 1             |
| 在最后加一个1         | (101101->1011011)      | x < < 1+1           |
| 把最后一位变成1       | (101100->101101)       | x \| 1              |
| 把最后一位变成0       | (101101->101100)       | x \| 1-1            |
| 最后一位取反          | (101101->101100)       | x ^ 1               |
| 把右数第k位变成1      | (101001->101101,k=3)   | x \| (1 < < (k-1))  |
| 把右数第k位变成0      | (101101->101001,k=3)   | x & ~ (1 < < (k-1)) |
| 右数第k位取反         | (101001->101101,k=3)   | x ^ (1 < < (k-1))   |
| 取末三位              | (1101101->101)         | x & 7               |
| 取末k位               | (1101101->1101,k=5)    | x & ((1 < < k)-1)   |
| 取右数第k位           | (1101101->1,k=4)       | x >> (k-1) & 1      |
| 把末k位变成1          | (101001->101111,k=4)   | x \| (1 < < k-1)    |
| 末k位取反             | (101001->100110,k=4)   | x ^ (1 < < k-1)     |
| 把右边连续的1变成0    | (100101111->100100000) | x & (x+1)           |
| 把右起第一个0变成1    | (100101111->100111111) | x \| (x+1)          |
| 把右边连续的0变成1    | (11011000->11011111)   | x \| (x-1)          |
| 取右边连续的1         | (100101111->1111)      | (x ^ (x+1)) >> 1    |
| 去掉右起第一个1的左边 | (100101000->1000)      | x & (x ^ (x-1))     |
| 判断奇数              |                        | (x&1)==1            |
| 判断偶数              |                        | (x&1)==0            |



- [Java基础](javascript:void(0))



- [Java基础](http://byteliu.com/categories/Java基础//)



扫一扫，分享到微信

![微信分享二维码](http://pan.baidu.com/share/qrcode?url=http://www.byteliu.com/2016/08/03/%E4%BD%8D%E8%BF%90%E7%AE%97/)